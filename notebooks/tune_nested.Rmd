```{r setup, include=FALSE}
interactive <- FALSE

## if running as interactive notebook mode (rather than script), enter the
## following parameters manually:


annots_dir <- "path/to/annotations"
db_path <- "path/to/database"
kmers_dir <- "path/to/kmers"
kmer <- 3
output <- "path/to/output"
antibiotics <- "all"
seed <- 42
folds <- 3
rounds <- 50
eta <- 2 / 50
pre_fold_info <- NULL
```

```{r wrap-args, include=FALSE}
if (interactive) {
  opt <- list(
    kmer = kmer,
    output = output,
    antibiotics = antibiotics,
    seed = seed,
    folds = folds,
    rounds = rounds,
    eta = eta,
    pre_fold_info = pre_fold_info
  )
  arguments <- list(
    args = list(annots_dir, db_path, kmers_dir),
    options = opt
  )
}
```

```{r setup-imports, include=FALSE}
suppressPackageStartupMessages({
  library(MIC)
  library(Biostrings)
  library(furrr)
  library(progressr)
  library(data.table)
  library(xgboost)
  library(tidyverse)
  library(AMR)
  library(caret)
  library(pryr)
  library(cli)
  library(optparse)
})
message("Imports complete")
```

```{r set-default-options, include=FALSE}
verbose <- TRUE

# antibiotics to iterate through
avail_abx <- c(
  "AMC", "AMK", "AMX", "CAZ", "CHL", "CIP", "FEP", "GEN", "MEM", "TGC")
all_abx <- c(
  "AMC", "AMK", "AMX", "CAZ", "CHL", "CIP", "FEP", "GEN", "MEM", "TGC")
```

```{r get-command-args, include=FALSE}
if (!interactive) {
  option_list <- list(
    make_option(c("-k", "--kmer"), type = "integer", default = 3,
                help = "k-mer value to use"),
    make_option(c("-o", "--output"), type = "character",
                help = "Path to store output files"),
    make_option(c("-a", "--antibiotics"), type = "character",
                help = "Antibiotics to process into subdirs,
                all, or comma-separated list of abx codes [default = none]"),
    make_option(c("-s", "--seed"), type = "integer", default = 42,
                help = "Seed for reproducibility [default = 42]"),
    make_option(c("-f", "--folds"), type = "integer", default = 3,
                help = "Number of folds for cross-validation [default = 3]"),
    make_option(c("-r", "--rounds"), type = "integer", default = 50,
                help = "Number of rounds for xgboost [default = 50]"),
    make_option(c("-e", "--eta"), type = "numeric", default = 2 / 50,
                help = "Learning rate for xgboost [default = 0.04]"),
    make_option(c("--pre_fold_info"), type = "character",
                help = "Path to precomputed fold information [default = none]
                        .RDS from previous run")
  )
  
  arguments <- parse_args(
    OptionParser(option_list = option_list,
    usage = "Usage: %prog [options] annots_dir db_path kmers_dir"),
    positional_arguments = 3)
  
  opt <- arguments$options
}
```

```{r check-args, include=FALSE}
if (!dir.exists(arguments$args[[1]])) {
  stop("Annotations directory does not exist")
}

if (!file.exists(arguments$args[[2]])) {
  stop("Database directory does not exist")
}

if (!dir.exists(arguments$args[[3]])) {
  stop("Kmers directory does not exist")
}

if (!is.null(opt$output)) {
  if (!dir.exists(opt$output)) {
    dir.create(opt$output, recursive = TRUE)
  }
}

if (!is.null(opt$pre_fold_info)) {
  if (!file.exists(opt$pre_fold_info)) {
    stop("Precomputed fold information does not exist")
  }
}

if (!is.null(opt$antibiotics)) {
  if (opt$antibiotics == "all") {
    all_abx <- avail_abx
  } else {
    all_abx <- strsplit(opt$antibiotics, ",")[[1]]
  }
  if (any(!all_abx %in% avail_abx)) {
    stop("Invalid antibiotics")
  }
}

if (length(all_abx) == 1) {
  message("Only one antibiotic provided. Will store output in individual
  files, prefixed with abx code")
  prefix <- paste0(all_abx, "_")
} else {
  message("Multiple antibiotics provided. Output from multiple antibiotics
  will be stored in combined files.")
  prefix <- NULL
}
```

```{r setup-settings, include=FALSE}
plan(multisession, workers = availableCores())
set.seed(opt$seed)
```

```{r setup-paths}
annots_path <- arguments$args[[1]]
db_path <- arguments$args[[2]]
kmers_dir <- arguments$args[[3]]
if (is.null(kmers_dir)) {
  warning("No kmers directory provided, will use current working directory")
  kmers_dir <- getwd()
}
if (is.null(opt$output)) {
  outpath <- getwd()
} else {
  outpath <- opt$output
}
```

```{r def-global-funs}
clean_up_genome_name <- function(x) {
  basename(tools::file_path_sans_ext(x))
}

chunk_msg <- function(msg) {
  if (verbose) {
    message(col_yellow(msg))
  }
}

memory_usage <- function(format = "GB") {
  mem <- pryr::mem_used() |> as.numeric()
  paste(
    switch(format,
         "GB" = mem / 1e9,
         "MB" = mem / 1e6,
         "KB" = mem / 1e3,
         "B" = mem),
    format)
}

kmer_abx_dir <- function(abx) {
  file.path(kmers_dir, paste0("kmers_", opt$kmer), abx)
}

kmer_abx_names <- function(abx) {
  file.path(kmer_abx_dir(abx), "names.csv")
}

kmer_abx_train <- function(abx) {
  file.path(kmer_abx_dir(abx), "train.txt")
}

val_fold <- function(f, n, right = TRUE) {
  ## given n folds, return the validation fold for fold f
  ## the validation fold is the next fold in the sequence to the right (or left)
  ## of fold f
  if (f > n) {
    stop("Fold number cannot be greater than number of folds")
  }
  if (right) {
    val_f <- ((f + 1) %% (n + 1))
    if (val_f == 0) {
      val_f <- 1
    }
    return(val_f)
  } else {
    val_f <- ((f - 1) %% (n + 1))
    if (val_f == 0) {
      val_f <- n
    }
    return(val_f)
  }
}
```

```{r verbose-update-before-work}
if (verbose) {
  chunk_msg("Tuning using the following input parameters/options:")
  message("Memory usage before tuning: ", memory_usage())
  message("Tuning ", length(all_abx), " antibiotics")
  message(paste(all_abx, collapse = ","))
  message("Kmers directory: ", kmers_dir)
  message("Database directory: ", db_path)
  message("Output directory: ", outpath)
  message("Seed: ", opt$seed)
  message("K-mer value: ", opt$kmer)
  message("Number of folds: ", opt$folds)
  message("Number of rounds: ", opt$rounds)
  message("Learning rate: ", opt$eta)
  message("Precomputed fold information: ", opt$pre_fold_info)
  if (!is.null(opt$pre_fold_info)) {
    warning("Pre-fold info file provided, therefore --folds will be ignored")
  }
}
```

```{r load-meta-data}
chunk_msg("Loading meta data from database..")
if (tools::file_ext(db_path) == "rds") {
  all_meta_adjusted <- read_rds(db_path)
  if (!inherits(all_meta_adjusted, "tidy_patric_db")) {
    stop("Database does not appear to be a tidy_patric_db object")
  }
} else {
  all_meta_adjusted <- tidy_patric_meta_data(load_patric_db(db_path))
}
```

```{r make-annots}
chunk_msg("Loading annotations..")
annots_file_paths <- list.files(
  annots_path, pattern = ".tsv", full.names = TRUE)
annots <- read_tsv(
  annots_file_paths,
  id = "genome_id",
  col_types = cols(.default = "c")) %>%
      select(genome_id, `Gene symbol`) %>%
      mutate(across(all_of("genome_id"), clean_up_genome_name)) %>%
      distinct(genome_id, `Gene symbol`) %>%
      mutate(value = 1) %>%
      pivot_wider(
        names_from = `Gene symbol`,
        values_from = value,
        values_fill = list(value = 0)) %>%
      group_by(genome_id) %>%
      summarise(across(everything(), sum), .groups = "drop")

# some (well, only 1) genomes have no positive annotations
# need to fill these
all_annot_ids <- unname(sapply(annots_file_paths, clean_up_genome_name))
annots_fill <- data.frame(
  genome_id = all_annot_ids[!all_annot_ids %in% annots$genome_id])
annots <- bind_rows(annots, annots_fill) %>%
  mutate(across(everything(), ~ replace_na(., 0)))
```

```{r init-containers}
chunk_msg("Initialising containers..")
step1_tune_kmer <- list()
step2_tune_kmer <- list()
step1_tune_annots <- list()
step2_tune_annots <- list()
model_log_kmer <- list()
model_log_annots <- list()
k_folds_log <- list()
predictions_kmer_log <- list()
predictions_annots_log <- list()
ea_kmer_log <- list()
ea_annots_log <- list()
```

```{r make-annots-matrix}
chunk_msg("Converting annotations to matrix..")
annots_ids <- annots$genome_id
annots_mat <- annots
annots_mat$genome_id <- NULL
annots_mat <- as.matrix(annots_mat)
rownames(annots_mat) <- annots_ids
write_rds(annots_mat, file.path(outpath, paste0(prefix, "annots_mat.rds")))
```

```{r make-folds}
if (!is.null(opt$pre_fold_info)) {
  chunk_msg("Loading precomputed fold information..")
  folds_tune_genome_names <- read_rds(opt$pre_fold_info)
  folds_tune <- list()
  # convert genome names to genome ids
  for (i in seq_along(folds_tune_genome_names)) {
    abx <- all_abx[[i]]
    if (file.exists(kmer_abx_names(abx))) {
      genome_ids <- read_csv(
        kmer_abx_names(abx),
        col_types = cols(.default = "c"))
      genome_ids <- genome_ids$name
      genome_ids <- clean_up_genome_name(genome_ids)
      
      folds_tune[[abx]] <- lapply(folds_tune_genome_names[[abx]], \(x) {
        which(genome_ids %in% x)
      })
      
    } else {
      genome_ids <- rownames(annots_mat)
      folds_tune[[abx]] <- lapply(folds_tune_genome_names[[abx]], \(x) {
        which(genome_ids %in% x)
      })
    }
  }
} else {

  chunk_msg("Making tuning cross-validation folds..")
  folds_tune <- list()
  folds_tune_genome_names <- list()
  for (i in seq_along(all_abx)) {
    abx <- all_abx[i]
    message("Making folds:", abx)
    if (file.exists(kmer_abx_names(abx))) {
      message(
        "kmer data appears to be present, will use kmer order to create folds")
      genome_ids <- read_csv(
        kmer_abx_names(abx),
        col_types = cols(.default = "c"))
      genome_ids <- genome_ids$name
      genome_ids <- clean_up_genome_name(genome_ids)
  
      mics <- get_mic(
        all_meta_adjusted,
        genome_ids, paste0("mic_", abx))
  
      stopifnot(all(!is.na(mics)))
  
    } else {
      message("kmer data not found, will use annotations order to create folds")
      genome_ids <- rownames(annots_mat)
      
      all_mics <- get_mic(
        all_meta_adjusted,
        genome_ids, paste0("mic_", abx))
  
      annots_mat_filtered <- annots_mat %>%
        subset(!is.na(all_mics))
  
      mics <- get_mic(
        all_meta_adjusted,
        genome_ids, paste0("mic_", abx))
    }
  
    labels <- mics %>%
      mic_uncensor() %>%
      log2()
  
    folds_tune[[abx]] <- caret::createFolds(
      labels, k = opt$folds, list = TRUE)
    
    folds_tune_genome_names[[abx]] <- lapply(folds_tune[[abx]], \(x) {
      genome_ids[x]
    })
  }
}
write_rds(folds_tune, file.path(outpath, paste0(prefix, "folds_tune.rds")))
write_rds(folds_tune_genome_names, file.path(outpath, paste0(prefix, "folds_tune_genome_names.rds")))
```

```{r tune-kmer}
chunk_msg("Tuning kmer models..")
for (i in seq_along(all_abx)) {
  abx <- all_abx[i]
  message("Flushing memory of old loaded data..")
  suppressWarnings(
    remove("dtrain")
  )
  gc()
  message("Tuning kmers:", abx)
  train_path <- kmer_abx_train(abx)
  names_path <- kmer_abx_names(abx)

  genome_ids <- read_csv(names_path, col_types = cols(.default = "c"))
  genome_ids <- genome_ids$name
  genome_ids <- clean_up_genome_name(genome_ids)

  ## step 1 tuning, subsample and colsample
  step1_params <- expand.grid(max_depth = c(2, 3, 4, 5),
                            min_child_weight = c(1, 5, 10))

  mics <- get_mic(
    all_meta_adjusted,
    genome_ids, paste0("mic_", abx))

  labels <- mics %>%
    mic_uncensor() %>%
    log2()

  message("Loading kmer data..")
  dall <- xgb.DMatrix(data = train_path, label = labels)
  message("Memory usage after loading kmer data:", memory_usage())

  # use nested cross validation, outer loop being cross validation, inner loop
  # using a train-test split with test being the next fold
  all_folds <- folds_tune[[abx]]
  step1_tune_inner <- lapply(seq_along(all_folds), function(f) {
      holdout_f <- f
      val_f <- val_fold(f, length(all_folds))
      holdout_indices <- all_folds[[holdout_f]]
      val_indices <- all_folds[[val_f]]
      # train is the remaining indices
      train_indices <- setdiff(
        unlist(all_folds), c(holdout_indices, val_indices))
      stopifnot(length(intersect(train_indices, holdout_indices)) == 0)
      
      dtrain <- xgboost::slice(dall, train_indices)
      dtest <- xgboost::slice(dall, val_indices)
      stopifnot(nrow(dtrain) + nrow(dtest) + length(holdout_indices) == nrow(dall))
      
      apply(step1_params, 1, function(x) {
        max_depth <- x[["max_depth"]]
        min_child_weight <- x[["min_child_weight"]]
        print(
          paste(
            "max_depth:", max_depth,
            "; min_child_weight: ", min_child_weight))
        
        m <- xgb.train(
          data = dtrain,
          watchlist = list(train = dtrain, eval = dtest),
          nrounds = opt$rounds,
          eta = opt$eta,
          max_depth = max_depth,
          min_child_weight = min_child_weight,
          print_every_n = 10
        )
        print(paste("Current memory usage:", memory_usage()))
        m
      })
    })
    
    step1_tune_kmer[[abx]] <- step1_tune_inner
    
    eval_log <- lapply(step1_tune_inner, function(x) {
      sapply(x, function(y) {
        y$evaluation_log[nrow(y$evaluation_log), "eval_rmse"]
      }) %>% 
        unlist()
    })
    
    step1_param_results <- lapply(eval_log, \(l) {
      step1_params %>%
        mutate(eval_rmse = l)
    })
    
    best_max_depth <- lapply(step1_param_results, \(x) {
      x[which.min(x$eval_rmse), "max_depth"]
    })
    best_min_child_weight <- lapply(step1_param_results, \(x) {
      x[which.min(x$eval_rmse), "min_child_weight"]
    })
    
  write_rds(step1_tune_kmer, file.path(outpath, paste0(prefix, "step1_tune_kmer.rds")))

     # ## step 2 tuning, subsample and colsample
  step2_params <- expand.grid(subsample = c(0.5, 0.75, 1),
                            colsample_bytree = c(0.4, 0.6, 0.8, 1))

  step2_tune_inner <- lapply(seq_along(all_folds), function(f) {
    holdout_f <- f
    val_f <- val_fold(f, length(all_folds))
    holdout_indices <- all_folds[[holdout_f]]
    val_indices <- all_folds[[val_f]]
    # train is the remaining indices
    train_indices <- setdiff(
      unlist(all_folds), c(holdout_indices, val_indices))
    stopifnot(length(intersect(train_indices, holdout_indices)) == 0)
    stopifnot(length(intersect(train_indices, val_indices)) == 0)

    dtrain <- xgboost::slice(dall, train_indices)
    dtest <- xgboost::slice(dall, val_indices)
    stopifnot(nrow(dtrain) + nrow(dtest) + length(holdout_indices) == nrow(dall))
    
    apply(step2_params, 1, function(x) {
      subsample <- x[["subsample"]]
      colsample_bytree <- x[["colsample_bytree"]]
      print(
        paste(
          "subsample:", subsample,
          "; colsample_bytree:", colsample_bytree))
      
      m <- xgb.train(
        data = dtrain,
        watchlist = list(train = dtrain, eval = dtest),
        nrounds = opt$rounds,
        eta = opt$eta,
        max_depth = best_max_depth[[f]],
        min_child_weight = best_min_child_weight[[f]],
        subsample = subsample,
        colsample_bytree = colsample_bytree,
        print_every_n = 10
      )
      print(paste("Current memory usage:", memory_usage()))
      m
    })
    })
    
    step2_tune_kmer[[abx]] <- step2_tune_inner
    
    eval_log <- lapply(step2_tune_inner, function(x) {
      sapply(x, function(y) {
        y$evaluation_log[nrow(y$evaluation_log), "eval_rmse"]
      }) %>% 
        unlist()
    })
    
    step2_param_results <- lapply(eval_log, \(l) {
      step2_params %>% 
      mutate(eval_rmse = l)
    })
    
    write_rds(step2_tune_kmer, file.path(outpath, paste0(prefix, "step2_tune_kmer.rds")))
    
  # 
  # step1_tune_inner <- apply(step1_params, 1, function(x) {
  #   max_depth <- x[["max_depth"]]
  #   min_child_weight <- x[["min_child_weight"]]
  #   print(
  #     paste(
  #       "max_depth:", max_depth,
  #       "; min_child_weight: ", min_child_weight))
  # 
  #   m <- xgb.cv(
  #     data = dtrain,
  #     nrounds = opt$rounds,
  #     eta = opt$eta,
  #     max_depth = max_depth,
  #     min_child_weight = min_child_weight,
  #     folds = folds_tune[[abx]]
  #   )
  #   print(paste("Current memory usage:", memory_usage()))
  #   m
  # })
  # 
  # step1_tune_kmer[[abx]] <- step1_tune_inner
  # 
  # eval_log <- step1_tune_inner %>%
  #   sapply(\(x) x$evaluation_log[nrow(x$evaluation_log), "test_rmse_mean"]) %>%
  #   unlist
  # 
  # step1_param_results <- step1_params
  # step1_param_results$eval_rmse <- eval_log
  # best_max_depth <- step1_param_results[which.min(eval_log), "max_depth"]
  # best_min_child_weight <- step1_param_results[which.min(
  #   eval_log), "min_child_weight"]
  # 
  # print(
  #   ggplot(step1_param_results,
  #          aes(x = max_depth, y = min_child_weight, fill = eval_rmse)) +
  #     geom_tile() +
  #     scale_fill_viridis_c() +
  #     theme_minimal()
  # )
  # 
  # write_rds(step1_tune_kmer, file.path(outpath, paste0(prefix, "step1_tune_kmer.rds")))
  # 
  # ## step 2 tuning, subsample and colsample
  # step2_params <- expand.grid(subsample = c(0.5, 0.75, 1),
  #                           colsample_bytree = c(0.4, 0.6, 0.8, 1))
  # 
  # step2_tune_inner <- apply(step2_params, 1, function(x) {
  #   subsample <- x[["subsample"]]
  #   colsample_bytree <- x[["colsample_bytree"]]
  #   print(
  #     paste(
  #       "subsample:", subsample,
  #       "; colsample_bytree:", colsample_bytree))
  # 
  #   m <- xgb.cv(
  #     data = dtrain,
  #     nrounds = opt$rounds,
  #     max_depth = best_max_depth,
  #     min_child_weight = best_min_child_weight,
  #     eta = opt$eta,
  #     subsample = subsample,
  #     colsample_bytree = colsample_bytree,
  #     folds = folds_tune[[abx]],
  #     print_every_n = 10
  #   )
  #   print(paste("Current memory usage:", memory_usage()))
  #   m
  # })
  # 
  # step2_tune_kmer[[abx]] <- step2_tune_inner
  # 
  # eval_log <- step2_tune_inner %>%
  #   sapply(\(x) x$evaluation_log[nrow(x$evaluation_log), "test_rmse_mean"]) %>%
  #   unlist
  # step2_param_results <- step2_params
  # step2_param_results$eval_rmse <- eval_log
  # 
  # print(
  #   ggplot(step2_param_results,
  #          aes(x = subsample, y = colsample_bytree, fill = eval_rmse)) +
  #     geom_tile() +
  #     scale_fill_viridis_c() +
  #     theme_minimal()
  # )

  # write_rds(step2_tune_kmer, file.path(outpath, paste0(prefix, "step2_tune_kmer.rds")))
}
```

```{r tune-annots, eval=TRUE}
chunk_msg("Tuning annotations models..")
for (i in seq_along(all_abx)) {
  abx <- all_abx[i]
  message("Tuning annots:", abx)

  if (file.exists(kmer_abx_names(abx))) {
    message("kmer data appears to be present, will try to match annotations data
    to the same order..")
    genome_ids <- suppressMessages(
      read_csv(kmer_abx_names(abx))
    )
    genome_ids <- genome_ids$name
    genome_ids <- clean_up_genome_name(genome_ids)
    annots_mat_filtered <- annots_mat[match(genome_ids, rownames(annots_mat)), ]
    stopifnot(all(rownames(annots_mat_filtered) == genome_ids))
  } else {
    all_mics <- get_mic(
      all_meta_adjusted,
      rownames(annots_mat), paste0("mic_", abx))
    annots_mat_filtered <- annots_mat %>%
      subset(!is.na(all_mics))
  }

  ## step 1 tuning, subsample and colsample
  step1_params <- expand.grid(max_depth = c(4, 6, 8, 10),
                            min_child_weight = c(1, 5, 10))

  mics <- get_mic(
    all_meta_adjusted,
    rownames(annots_mat_filtered), paste0("mic_", abx))

  labels <- mics %>%
    mic_uncensor() %>%
    log2()

  stopifnot(all(!is.na(labels)))

  dall <- xgb.DMatrix(data = annots_mat_filtered, label = labels)
  
  all_folds <- folds_tune[[abx]]
  step1_tune_inner <- lapply(seq_along(all_folds), function(f) {
    holdout_f <- f
    val_f <- val_fold(f, length(all_folds))
    holdout_indices <- all_folds[[holdout_f]]
    val_indices <- all_folds[[val_f]]
    # train is the remaining indices
    train_indices <- setdiff(
      unlist(all_folds), c(holdout_indices, val_indices))
    stopifnot(length(intersect(train_indices, holdout_indices)) == 0)
    
    dtrain <- xgboost::slice(dall, train_indices)
    dtest <- xgboost::slice(dall, val_indices)
    stopifnot(nrow(dtrain) + nrow(dtest) + length(holdout_indices) == nrow(dall))
    
    apply(step1_params, 1, function(x) {
      max_depth <- x[["max_depth"]]
      min_child_weight <- x[["min_child_weight"]]
      print(
        paste(
          "max_depth:", max_depth,
          "; min_child_weight: ", min_child_weight))
      
      m <- xgb.train(
        data = dtrain,
        watchlist = list(train = dtrain, eval = dtest),
        nrounds = opt$rounds,
        eta = opt$eta,
        max_depth = max_depth,
        min_child_weight = min_child_weight,
        print_every_n = 10
      )
      print(paste("Current memory usage:", memory_usage()))
      m
    })
  })
    
    step1_tune_annots[[abx]] <- step1_tune_inner
    
    eval_log <- lapply(step1_tune_inner, function(x) {
      sapply(x, function(y) {
        y$evaluation_log[nrow(y$evaluation_log), "eval_rmse"]
      }) %>% 
        unlist()
    })
    
    step1_param_results <- lapply(eval_log, \(l) {
      step1_params %>%
        mutate(eval_rmse = l)
    })
    
    best_max_depth <- lapply(step1_param_results, \(x) {
      x[which.min(x$eval_rmse), "max_depth"]
    })
    
    best_min_child_weight <- lapply(step1_param_results, \(x) {
      x[which.min(x$eval_rmse), "min_child_weight"]
    })
    
    write_rds(step1_tune_annots, file.path(outpath, paste0(prefix, "step1_tune_annots.rds")))
    
    # ## step 2 tuning, subsample and colsample
    
    step2_params <- expand.grid(subsample = c(0.5, 0.75, 1),
                              colsample_bytree = c(0.4, 0.6, 0.8, 1))
    
    step2_tune_inner <- lapply(seq_along(all_folds), function(f) {
      holdout_f <- f
      val_f <- val_fold(f, length(all_folds))
      holdout_indices <- all_folds[[holdout_f]]
      val_indices <- all_folds[[val_f]]
      # train is the remaining indices
      train_indices <- setdiff(
        unlist(all_folds), c(holdout_indices, val_indices))
      stopifnot(length(intersect(train_indices, holdout_indices)) == 0)
      
      dtrain <- xgboost::slice(dall, train_indices)
      dtest <- xgboost::slice(dall, val_indices)
      stopifnot(nrow(dtrain) + nrow(dtest) + length(holdout_indices) == nrow(dall))
      
      apply(step2_params, 1, function(x) {
        subsample <- x[["subsample"]]
        colsample_bytree <- x[["colsample_bytree"]]
        print(
          paste(
            "subsample:", subsample,
            "; colsample_bytree:", colsample_bytree))
        
        m <- xgb.train(
          data = dtrain,
          watchlist = list(train = dtrain, eval = dtest),
          nrounds = opt$rounds,
          eta = opt$eta,
          max_depth = best_max_depth[[f]],
          min_child_weight = best_min_child_weight[[f]],
          subsample = subsample,
          colsample_bytree = colsample_bytree,
          print_every_n = 10
        )
        print(paste("Current memory usage:", memory_usage()))
        m
      })
    })
    
    step2_tune_annots[[abx]] <- step2_tune_inner
    
    eval_log <- lapply(step2_tune_inner, function(x) {
      sapply(x, function(y) {
        y$evaluation_log[nrow(y$evaluation_log), "eval_rmse"]
      }) %>% 
        unlist()
    })
    
    step2_param_results <- lapply(eval_log, \(l) {
      step2_params %>% 
      mutate(eval_rmse = l)
    })
    
    write_rds(step2_tune_annots, file.path(outpath, paste0(prefix, "step2_tune_annots.rds")))

  # step1_tune_inner <- apply(step1_params, 1, function(x) {
  #   max_depth <- x[["max_depth"]]
  #   min_child_weight <- x[["min_child_weight"]]
  #   print(
  #     paste("max_depth:", max_depth,
  #     "; min_child_weight: ", min_child_weight))
  # 
  #   m <- xgb.cv(
  #     data = dtrain,
  #     nrounds = opt$rounds,
  #     eta = opt$eta,
  #     max_depth = max_depth,
  #     min_child_weight = min_child_weight,
  #     folds = folds_tune[[abx]],
  #     print_every_n = 10
  #   )
  #   print(paste("Current memory usage:", memory_usage()))
  #   m
  # })
  # 
  # step1_tune_annots[[abx]] <- step1_tune_inner
  # 
  # eval_log <- step1_tune_inner %>%
  #   sapply(\(x) x$evaluation_log[nrow(x$evaluation_log), "test_rmse_mean"]) %>%
  #   unlist
  # 
  # step1_param_results <- step1_params
  # step1_param_results$eval_rmse <- eval_log
  # best_max_depth <- step1_param_results[which.min(eval_log), "max_depth"]
  # best_min_child_weight <- step1_param_results[which.min(
  #   eval_log), "min_child_weight"]
  # 
  # print(
  #   ggplot(step1_param_results,
  #          aes(x = max_depth, y = min_child_weight, fill = eval_rmse)) +
  #     geom_tile() +
  #     scale_fill_viridis_c() +
  #     theme_minimal()
  # )
  # 
  # write_rds(step1_tune_annots, file.path(outpath, paste0(prefix, "step1_tune_annots.rds")))
  # 
  # ## step 2 tuning, subsample and colsample
  # step2_params <- expand.grid(subsample = c(0.5, 0.75, 1),
  #                           colsample_bytree = c(0.4, 0.6, 0.8, 1))
  # 
  # step2_tune_inner <- apply(step2_params, 1, function(x) {
  #   subsample <- x[["subsample"]]
  #   colsample_bytree <- x[["colsample_bytree"]]
  #   print(
  #     paste(
  #       "subsample:", subsample,
  #       "; colsample_bytree: ", colsample_bytree))
  # 
  #   m <- xgb.cv(
  #     data = dtrain,
  #     nrounds = opt$rounds,
  #     max_depth = best_max_depth,
  #     min_child_weight = best_min_child_weight,
  #     eta = opt$eta,
  #     subsample = subsample,
  #     colsample_bytree = colsample_bytree,
  #     folds = folds_tune[[abx]],
  #     print_every_n = 10
  #   )
  #   print(paste("Current memory usage:", memory_usage()))
  #   m
  # })
  # 
  # step2_tune_annots[[abx]] <- step2_tune_inner
  # 
  # eval_log <- step2_tune_inner %>%
  #   sapply(\(x) x$evaluation_log[nrow(x$evaluation_log), "test_rmse_mean"]) %>%
  #   unlist
  # step2_param_results <- step2_params
  # step2_param_results$eval_rmse <- eval_log
  # 
  # print(
  #   ggplot(step2_param_results,
  #          aes(x = subsample, y = colsample_bytree, fill = eval_rmse)) +
  #     geom_tile() +
  #     scale_fill_viridis_c() +
  #     theme_minimal()
  # )
  # 
  # write_rds(step2_tune_annots, file.path(outpath, paste0(prefix, "step2_tune_annots.rds")))
}
```

```{r tune-only-stop}
chunk_msg("Tuning complete")
q()
```
